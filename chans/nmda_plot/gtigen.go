// Code generated by "goki generate ./..."; DO NOT EDIT.

package main

import (
	"goki.dev/gti"
	"goki.dev/ordmap"
)

var _ = gti.AddType(&gti.Type{
	Name:       "main.Sim",
	ShortName:  "main.Sim",
	IDName:     "sim",
	Doc:        "Sim holds the params, table, etc",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NMDAStd", &gti.Field{Name: "NMDAStd", Type: "invalid type", LocalType: "chans.NMDAParams", Doc: "standard NMDA implementation in chans", Directives: gti.Directives{}, Tag: ""}},
		{"NMDAv", &gti.Field{Name: "NMDAv", Type: "float64", LocalType: "float64", Doc: "multiplier on NMDA as function of voltage", Directives: gti.Directives{}, Tag: "def:\"0.062\""}},
		{"MgC", &gti.Field{Name: "MgC", Type: "float64", LocalType: "float64", Doc: "magnesium ion concentration -- somewhere between 1 and 1.5", Directives: gti.Directives{}, Tag: ""}},
		{"NMDAd", &gti.Field{Name: "NMDAd", Type: "float64", LocalType: "float64", Doc: "denominator of NMDA function", Directives: gti.Directives{}, Tag: "def:\"3.57\""}},
		{"NMDAerev", &gti.Field{Name: "NMDAerev", Type: "float64", LocalType: "float64", Doc: "NMDA reversal / driving potential", Directives: gti.Directives{}, Tag: "def:\"0\""}},
		{"BugVoff", &gti.Field{Name: "BugVoff", Type: "float64", LocalType: "float64", Doc: "for old buggy NMDA: voff value to use", Directives: gti.Directives{}, Tag: ""}},
		{"Vstart", &gti.Field{Name: "Vstart", Type: "float64", LocalType: "float64", Doc: "starting voltage", Directives: gti.Directives{}, Tag: "def:\"-90\""}},
		{"Vend", &gti.Field{Name: "Vend", Type: "float64", LocalType: "float64", Doc: "ending voltage", Directives: gti.Directives{}, Tag: "def:\"10\""}},
		{"Vstep", &gti.Field{Name: "Vstep", Type: "float64", LocalType: "float64", Doc: "voltage increment", Directives: gti.Directives{}, Tag: "def:\"1\""}},
		{"Tau", &gti.Field{Name: "Tau", Type: "float64", LocalType: "float64", Doc: "decay time constant for NMDA current -- rise time is 2 msec and not worth extra effort for biexponential", Directives: gti.Directives{}, Tag: "def:\"100\""}},
		{"TimeSteps", &gti.Field{Name: "TimeSteps", Type: "int", LocalType: "int", Doc: "number of time steps", Directives: gti.Directives{}, Tag: ""}},
		{"TimeV", &gti.Field{Name: "TimeV", Type: "float64", LocalType: "float64", Doc: "voltage for TimeRun", Directives: gti.Directives{}, Tag: ""}},
		{"TimeGin", &gti.Field{Name: "TimeGin", Type: "float64", LocalType: "float64", Doc: "NMDA Gsyn current input at every time step", Directives: gti.Directives{}, Tag: ""}},
		{"Table", &gti.Field{Name: "Table", Type: "*goki.dev/etable/v2/etable.Table", LocalType: "*etable.Table", Doc: "table for plot", Directives: gti.Directives{}, Tag: "view:\"no-inline\""}},
		{"Plot", &gti.Field{Name: "Plot", Type: "*goki.dev/etable/v2/eplot.Plot2D", LocalType: "*eplot.Plot2D", Doc: "the plot", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"TimeTable", &gti.Field{Name: "TimeTable", Type: "*goki.dev/etable/v2/etable.Table", LocalType: "*etable.Table", Doc: "table for plot", Directives: gti.Directives{}, Tag: "view:\"no-inline\""}},
		{"TimePlot", &gti.Field{Name: "TimePlot", Type: "*goki.dev/etable/v2/eplot.Plot2D", LocalType: "*eplot.Plot2D", Doc: "the plot", Directives: gti.Directives{}, Tag: "view:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{
		{"Run", &gti.Method{Name: "Run", Doc: "Run runs the equation.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"TimeRun", &gti.Method{Name: "TimeRun", Doc: "TimeRun runs the equation over time.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
	}),
})
