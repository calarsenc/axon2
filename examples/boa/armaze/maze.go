// Copyright (c) 2023, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package armaze represents an N-armed maze ("bandit")
// with each Arm having a distinctive CS stimulus at the start
// (could be one of multiple possibilities) and (some probability of)
// a US outcome at the end of the maze (could be either positive
// or negative, with (variable) magnitude and probability.
package armaze

import (
	"fmt"

	"github.com/emer/emergent/econfig"
	"github.com/emer/emergent/env"
	"github.com/emer/emergent/erand"
	"github.com/emer/etable/etensor"
	"github.com/goki/ki/kit"
)

// Actions is a list of mutually exclusive states
// for tracing the behavior and internal state of Emery
type Actions int

const (
	Forward Actions = iota
	Left
	Right
	Consume
	None
	ActionsN
)

//go:generate stringer -type=Actions

var KiT_Actions = kit.Enums.AddEnum(ActionsN, kit.NotBitFlag, nil)

// General note on US / Drive indexes:
// The env does _not_ represent any built-in drives or USs (curiosity, effort, urgency)
// 0 = start of the sim-specific USs and Drives

// Maze implements an N-armed maze ("bandit")
// with each Arm having a distinctive CS stimulus visible at the start
// (could be one of multiple possibilities) and (some probability of)
// a US outcome at the end of the maze (could be either positive
// or negative, with (variable) magnitude and probability.
type Maze struct {

	// name of environment -- Train or Test
	Nm string `desc:"name of environment -- Train or Test"`

	// configuration parameters
	Config Config `desc:"configuration parameters"`

	// current drive strength for each of Config.NDrives in normalized 0-1 units of each drive: 0 = first sim drive, not curiosity
	Drives []float32 `desc:"current drive strength for each of Config.NDrives in normalized 0-1 units of each drive: 0 = first sim drive, not curiosity"`

	// parameters associated with each US.  The first NDrives are positive USs, and beyond that are negative USs
	USs []*USParams `desc:"parameters associated with each US.  The first NDrives are positive USs, and beyond that are negative USs"`

	// state of each arm: dist, effort, US, CS
	Arms []*Arm `desc:"state of each arm: dist, effort, US, CS"`

	// arm-wise location: either facing (Pos=0) or in (Pos > 0)
	Arm int `inactive:"+" desc:"arm-wise location: either facing (Pos=0) or in (Pos > 0)"`

	// current position in the Arm: 0 = at start looking in, otherwise at given distance into the arm
	Pos int `inactive:"+" desc:"current position in the Arm: 0 = at start looking in, otherwise at given distance into the arm"`

	// current target drive, in paradigms where that is used (e.g., Approach)
	TrgDrive int `inactive:"+" desc:"current target drive, in paradigms where that is used (e.g., Approach)"`

	// current target arm, in paradigms where that is used  (e.g., Approach)
	TrgArm int `inactive:"+" desc:"current target arm, in paradigms where that is used  (e.g., Approach)"`

	// Current US being consumed -- is -1 unless being consumed
	ConsumeUS int `inactive:"+" desc:"Current US being consumed -- is -1 unless being consumed"`

	// reward or punishment value generated by the current US being consumed
	USValue float32 `inactive:"+" desc:"reward or punishment value generated by the current US being consumed"`

	// last action taken
	LastAct int `inactive:"+" desc:"last action taken"`

	// last CS -- previous trial
	LastCS int `inactive:"+" desc:"last CS -- previous trial"`

	// true if looking at correct CS for first time
	ShouldGate bool `inactive:"+" desc:"true if looking at correct CS for first time"`

	// just gated on this trial
	JustGated bool `inactive:"+" desc:"just gated on this trial"`

	// has gated at some point during sequence
	HasGated bool `inactive:"+" desc:"has gated at some point during sequence"`

	// named states -- e.g., USs, CSs, etc
	States map[string]*etensor.Float32 `desc:"named states -- e.g., USs, CSs, etc"`

	// [view: -] random number generator for the env -- all random calls must use this
	Rand erand.SysRand `view:"-" desc:"random number generator for the env -- all random calls must use this"`

	// random seed
	RndSeed int64 `inactive:"+" desc:"random seed"`
}

const noUS = -1

func (ev *Maze) Name() string {
	return ev.Nm
}

func (ev *Maze) Desc() string {
	return "Maze"
}

// Defaults sets default params
func (ev *Maze) Defaults() {
	ev.Config.Defaults()
	econfig.SetFromDefaults(&ev.Config)
	ev.Config.Update()
}

// Config configures the world
// additional parameterization via specific configs
// is applied after this step, which initializes
// everything according to basic Ns
func (ev *Maze) Config() {
	if ev.Rand.Rand == nil {
		ev.Rand.NewRand(ev.RndSeed)
	} else {
		ev.Rand.Seed(ev.RndSeed)
	}

	switch ev.Config.Paradigm {
	case Approach:
		ev.ConfigApproach()
	}

	ev.Config.Update()

	ev.Drives = make([]float32, ev.Config.NDrives)
	ev.USs = make([]*USParams, ev.Config.NUSs)
	ev.Arms = make([]*Arm, ev.Config.NDrives)

	// defaults
	usperm := ev.Rand.Perm(ev.NUSs, -1)
	for i, arm := range ev.Arms {
		arm.Dist = 4
		arm.Effort.Set(1, 1)
		arm.US = usperm[i%ev.NUSs]
	}

	// defaults
	for i, us := range ev.USs {
		if i < ev.NDrives {
			us.Negative = false
		} else {
			us.Negative = true
		}
		us.Mag.Set(1, 1)
		us.Prob = 1
		us.CSProbs = make([]float32, ev.NCSs)
		us.CSProbs[i%ev.NCSs] = 1 // uniform allocation
	}

	ev.States = make(map[string]*etensor.Float32)
	ev.States["CS"] = etensor.NewFloat32([]int{ev.NYReps, ev.Config.NCSs}, nil, nil)
	ev.States["Action"] = etensor.NewFloat32([]int{ev.NYReps, NActions}, nil, nil)

	ev.NewStart()
}

func (ev *Maze) Validate() error {
	return nil
}

func (ev *Maze) Init(run int) {
	ev.Config()
}

func (ev *Maze) Counter(scale env.TimeScales) (cur, prv int, changed bool) {
	return 0, 0, false
}

func (ev *Maze) State(el string) etensor.Tensor {
	return ev.States[el]
}

// ChooseCSs selects new CSs for each Arm as function of US CSProbs
func (ev *Maze) NewStart() {
	for i, arm := range ev.Arms {
		us := ev.USs[arm.US]
		arm.CS = erand.PDist(us.CSProbs, -1, ev.Rand) // choose by dist
	}
}

// NewStart starts a new approach run
func (ev *Maze) NewStart() {
	if ev.Config.Params.RandomStart {
		ev.Arm = ev.Rand.Intn(ev.Arms, -1)
	}
	ev.Pos = 0
	ev.JustGated = false
	ev.HasGated = false

	switch ev.Config.Paradigm {
	case Approach:
		ev.StartApproach()
	}

	ev.ConsumeUS = -1
	ev.Rew = 0
	ev.RenderState()
	ev.RenderRewUS()
}

// RenderLocalist renders one localist state
func (ev *Maze) RenderLocalist(name string, val int) {
	st := ev.States[name]
	st.SetZeros()
	if val >= st.Dim(1) {
		return
	}
	for y := 0; y < ev.NYReps; y++ {
		st.Set([]int{y, val}, 1.0)
	}
}

// RenderLocalist4D renders one localist state in 4D
func (ev *Maze) RenderLocalist4D(name string, val int) {
	st := ev.States[name]
	st.SetZeros()
	for y := 0; y < ev.NYReps; y++ {
		st.Set([]int{0, val, y, 0}, 1.0)
	}
}

// RenderState renders the current state
func (ev *Maze) RenderState() {
	ev.RenderLocalist("Pos", ev.Pos)
	ev.RenderLocalist4D("Drives", ev.Drive)
	ev.RenderLocalist("Dist", ev.Dist)
	ev.RenderLocalist("Time", ev.Time)

	css := ev.States["CSs"]
	patn := int(css.Values[ev.Pos])
	/*
		pats := ev.States["Pats"]
		pat := pats.SubSpace([]int{patn})
		cs := ev.States["CS"]
		cs.CopyFrom(pat)
	*/
	ev.CS = patn
	ev.RenderLocalist("CS", patn)
}

// RenderRewUS renders reward and US
func (ev *Maze) RenderRewUS() {
	if ev.US < 0 {
		ev.RenderLocalist4D("US", ev.NDrives)
	} else {
		ev.RenderLocalist4D("US", ev.US)
	}
	rew := ev.States["Rew"]
	rew.Values[0] = ev.Rew
}

// RenderAction renders the action
func (ev *Maze) RenderAction(act int) {
	ev.RenderLocalist("Action", act)
}

// Step does one step
func (ev *Maze) Step() bool {
	ev.LastCS = ev.CS
	// This has the effect of delaying restarting the env until the
	// US is in place for 2 trials.
	if ev.LastUS != noUS {
		ev.NewStart()
	}
	ev.RenderState()
	ev.RenderRewUS()
	return true
}

func (ev *Maze) DecodeAct(vt *etensor.Float32) (int, string) {
	mxi := ev.DecodeLocalist(vt)
	return mxi, ev.Acts[mxi]
}

func (ev *Maze) DecodeLocalist(vt *etensor.Float32) int {
	dx := vt.Dim(1)
	var max float32
	var mxi int
	for i := 0; i < dx; i++ {
		var sum float32
		for j := 0; j < ev.NYReps; j++ {
			sum += vt.Value([]int{j, i})
		}
		if sum > max {
			max = sum
			mxi = i
		}
	}
	return mxi
}

func (ev *Maze) Action(action string, nop etensor.Tensor) {
	act, ok := ev.ActMap[action]
	if !ok {
		fmt.Printf("Action not recognized: %s\n", action)
		return
	}
	ev.LastUS = ev.US
	ev.RenderAction(act)
	ev.Time++
	switch action {
	case "Forward":
		if ev.Dist != 0 {
			ev.Dist--
		}
	case "Left":
		ev.Pos--
		if ev.Pos < 0 {
			ev.Pos += ev.Arms
		}
	case "Right":
		ev.Pos++
		if ev.Pos >= ev.Arms {
			ev.Pos -= ev.Arms
		}
	case "Consume":
		if ev.Dist == 0 {
			ev.SetRewFmUS()
		}
	}
	ev.LastAct = act
	ev.RenderRewUS()
	// fmt.Printf("ev Rew: %g\n", ev.Rew)
}

// SetRewFmUS set reward from US
func (ev *Maze) SetRewFmUS() {
	uss := ev.States["USs"]
	ev.US = int(uss.Values[ev.Pos])
	if ev.US == ev.Drive {
		ev.Rew = 1 - ev.TimeCost*float32(ev.Time)
	} else {
		ev.Rew = -ev.TimeCost * float32(ev.Time)
	}
}

// USForPos returns the US at given position
func (ev *Maze) USForPos() int {
	uss := ev.States["USs"]
	return int(uss.Values[ev.Pos])
}

// PosHasDriveUS returns true if the current USForPos corresponds
// to the current Drive -- i.e., are we looking at the right thing?a
func (ev *Maze) PosHasDriveUS() bool {
	return ev.Drive == ev.USForPos()
}

// InstinctAct returns an "instinctive" action that implements a basic policy
func (ev *Maze) InstinctAct(justGated, hasGated bool) int {
	ev.JustGated = justGated
	ev.HasGated = hasGated
	ev.ShouldGate = ((hasGated && ev.US != noUS) || // To clear the goal after US
		(!hasGated && ev.PosHasDriveUS())) // looking at correct, haven't yet gated

	if ev.Dist == 0 {
		return ev.ActMap["Consume"]
	}
	if ev.HasGated {
		return ev.ActMap["Forward"]
	}
	lt := ev.ActMap["Left"]
	rt := ev.ActMap["Right"]
	if ev.LastAct == lt || ev.LastAct == rt {
		return ev.LastAct
	}
	if ev.AlwaysLeft || erand.BoolP(.5, -1, &ev.Rand) {
		return lt
	}
	return rt
}
